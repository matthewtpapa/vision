name: SoT-Check (S1)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

permissions:
  contents: read

concurrency:
  group: s1-${{ github.ref }}
  cancel-in-progress: true

jobs:
  s1:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install tools
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install jsonschema
          sudo apt-get update -y
          sudo apt-get install -y wkhtmltopdf jq

      - name: Verify toolchain
        run: |
          set -euo pipefail
          wkhtmltopdf --version
          jq --version
          python -c "import jsonschema"

      - name: Apply seeds & capture env
        shell: bash
        run: |
          set -euo pipefail
          if [ -f seeds.env ]; then
            set -a
            . seeds.env
            set +a
          fi
          python scripts/capture_env.py
          test -s artifacts/seeds_applied.json
          python - <<'PY'
import json
from pathlib import Path
required = {"PYTHONHASHSEED", "VISION_SEED", "TZ"}
seeds = json.loads(Path("artifacts/seeds_applied.json").read_text(encoding="utf-8"))
missing = sorted(required - seeds.keys())
if missing:
    raise SystemExit(f"missing seed variables: {', '.join(missing)}")
PY

      - name: Record S1 START
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import json
from pathlib import Path
ledger = Path("artifacts/stage_ledger.jsonl")
ledger.parent.mkdir(parents=True, exist_ok=True)
ledger.touch(exist_ok=True)
record = {"stage": "S1", "event": "START"}
with ledger.open("a", encoding="utf-8") as handle:
    handle.write(json.dumps(record, separators=(",", ":")) + "\n")
PY

      - name: Build manifest and lock
        run: |
          set -euo pipefail
          python scripts/fileset.py
          test -s artifacts/manifest.json
          test -s roadmap.lock.json

      - name: Verify fileset sha parity
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import json
from pathlib import Path
manifest = json.loads(Path("artifacts/manifest.json").read_text(encoding="utf-8"))
lock = json.loads(Path("roadmap.lock.json").read_text(encoding="utf-8"))
if manifest.get("fileset_sha256") != lock.get("fileset_sha256"):
    raise SystemExit("fileset_sha256 mismatch")
PY

      - name: Enforce manifest path set parity
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import json
import subprocess
from pathlib import Path
from difflib import unified_diff
manifest = json.loads(Path("artifacts/manifest.json").read_text(encoding="utf-8"))["files"]
manifest_paths = sorted(entry["path"] for entry in manifest)
out = subprocess.check_output(["git", "ls-files", "-z"]).decode().split("\x00")
paths = sorted(
    path
    for path in out
    if path
    and not (
        path.startswith("artifacts/")
        or path.startswith("bench/")
        or path == "roadmap.lock.json"
        or path.endswith(".pyc")
        or "/__pycache__/" in path
    )
)
print(f"fileset_count_git={len(paths)}")
print(f"fileset_count_manifest={len(manifest_paths)}")
diff = list(unified_diff(paths, manifest_paths, fromfile="git", tofile="manifest", lineterm=""))
if diff:
    raise SystemExit("path-set mismatch:\n" + "\n".join(diff[:20]))
print("path_set_equal")
PY

      - name: Sign manifest
        if: ${{ secrets.SOT_DEV_SIGNING_KEY }}
        env:
          SOT_DEV_SIGNING_KEY: ${{ secrets.SOT_DEV_SIGNING_KEY }}
          SOT_KID: dev
        shell: bash
        run: |
          set -euo pipefail
          python scripts/sign_json.py artifacts/manifest.json
          python - <<'PY'
import hashlib
import hmac
import json
import os
from pathlib import Path
key = os.environ["SOT_DEV_SIGNING_KEY"].encode()
manifest_path = Path("artifacts/manifest.json")
signature_path = manifest_path.with_suffix(manifest_path.suffix + ".sig")
manifest_bytes = manifest_path.read_bytes()
expected_payload_sha = hashlib.sha256(manifest_bytes).hexdigest()
signature = json.loads(signature_path.read_text(encoding="utf-8"))
if signature.get("payload_sha256") != expected_payload_sha:
    raise SystemExit("payload_sha256 mismatch")
expected_sig = hmac.new(key, manifest_bytes, hashlib.sha256).hexdigest()
if signature.get("sig") != expected_sig:
    raise SystemExit("signature mismatch")
PY

      - name: Document missing signing secret
        if: ${{ !secrets.SOT_DEV_SIGNING_KEY }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p docs
          cat <<'DOC' > docs/BLOCKED.S1.md
# Stage S1 signing blocked

The `SOT_DEV_SIGNING_KEY` secret is unavailable, so the manifest cannot be signed.
Run the following once the secret is restored:

```bash
python scripts/sign_json.py artifacts/manifest.json
```
DOC

      - name: Purity guard
        shell: bash
        run: |
          set -euo pipefail
          bash scripts/purity_guard.sh
          python - <<'PY'
import json
from pathlib import Path
from jsonschema import validate
report_path = Path("artifacts/purity_report.json")
schema_path = Path("schemas/purity_report.schema.json")
report = json.loads(report_path.read_text(encoding="utf-8"))
schema = json.loads(schema_path.read_text(encoding="utf-8"))
validate(instance=report, schema=schema)
network_syscalls = report.get("network_syscalls")
if network_syscalls not in (False, 0):
    raise SystemExit("network syscalls detected")
offenders = report.get("offenders") or report.get("offending", [])
if offenders:
    raise SystemExit("purity offenders present")
PY

      - name: Render SoT PDF
        run: |
          set -euo pipefail
          mkdir -p artifacts
          wkhtmltopdf docs/Vision_v1_Investor_SoT.html artifacts/vision_v1_SoT.pdf
          wkhtmltopdf docs/Vision_v1_Investor_SoT.html artifacts/vision_v1_SoT.second.pdf
          cmp artifacts/vision_v1_SoT.pdf artifacts/vision_v1_SoT.second.pdf
          rm artifacts/vision_v1_SoT.second.pdf

      - name: Upload SoT PDF
        uses: actions/upload-artifact@v4
        with:
          name: vision_v1_SoT_pdf
          path: artifacts/vision_v1_SoT.pdf

      - name: Record S1 PASS
        shell: bash
        run: |
          set -euo pipefail
          python - <<'PY'
import json
from pathlib import Path
ledger = Path("artifacts/stage_ledger.jsonl")
ledger.parent.mkdir(parents=True, exist_ok=True)
record = {"stage": "S1", "event": "PASS"}
with ledger.open("a", encoding="utf-8") as handle:
    handle.write(json.dumps(record, separators=(",", ":")) + "\n")
PY
          printf 'stage=S1 PASS\n' > gate_summary.txt

      - name: Refresh ledger tip
        shell: bash
        run: |
          set -euo pipefail
          python scripts/ledger_tip.py

      - name: Ledger tip stability
        shell: bash
        run: |
          set -euo pipefail
          cmp -s artifacts/ledger_tip.txt <(python scripts/ledger_tip.py)
