name: Docs Drift Check

on:
  pull_request:
    paths:
      - 'docs/**'

defaults:
  run:
    shell: bash

jobs:
  docs-drift:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Compare stage specs with SoT
        run: |
          python - <<'PY'
          from __future__ import annotations

          import re
          from html.parser import HTMLParser
          from pathlib import Path


          class StageTableParser(HTMLParser):
              def __init__(self) -> None:
                  super().__init__()
                  self.in_table = False
                  self.in_tr = False
                  self.in_cell = False
                  self.current_id: str | None = None
                  self.current_cell: list[str] = []
                  self.current_row: list[str] = []
                  self.rows: dict[str, list[str]] = {}

              def handle_starttag(self, tag: str, attrs: list[tuple[str, str | None]]) -> None:
                  if tag == "table":
                      self.in_table = True
                  elif self.in_table and tag == "tr":
                      self.in_tr = True
                      self.current_id = None
                      for name, value in attrs:
                          if name == "id" and value:
                              self.current_id = value
                      self.current_row = []
                  elif self.in_tr and tag in {"td", "th"}:
                      self.in_cell = True
                      self.current_cell = []

              def handle_endtag(self, tag: str) -> None:
                  if tag == "table":
                      self.in_table = False
                  elif self.in_table and tag == "tr":
                      if self.current_id and self.current_row:
                          self.rows[self.current_id] = self.current_row
                      self.in_tr = False
                      self.current_id = None
                  elif self.in_tr and tag in {"td", "th"}:
                      if self.in_cell:
                          cell_text = "".join(self.current_cell).strip()
                          self.current_row.append(cell_text)
                      self.in_cell = False

              def handle_data(self, data: str) -> None:
                  if self.in_cell:
                      self.current_cell.append(data)


          def normalize_text(text: str) -> str:
              text = text.replace("\xa0", " ")
              text = text.replace("**", "")
              text = re.sub(r"\s+", " ", text)
              return text.strip()


          sot_path = Path("docs/Vision_v1_Investor_SoT.html")
          parser = StageTableParser()
          parser.feed(sot_path.read_text(encoding="utf-8"))

          expected_codes = {f"S{num:02d}" for num in range(1, 18)}
          missing_in_table = expected_codes - parser.rows.keys()
          if missing_in_table:
              raise SystemExit(f"Missing rows in SoT table: {sorted(missing_in_table)}")

          errors: list[str] = []
          for stage_md in sorted(Path("docs/specs/stages").glob("S*.md")):
              code = stage_md.stem
              if code not in parser.rows:
                  errors.append(f"Stage {code} not found in SoT table")
                  continue

              lines = stage_md.read_text(encoding="utf-8").splitlines()
              acceptance_lines: list[str] = []
              in_acceptance = False
              for line in lines:
                  if line.strip() == "## Acceptance (CI-verified)":
                      in_acceptance = True
                      continue
                  if in_acceptance:
                      if line.startswith("## "):
                          break
                      if line.strip().startswith("- "):
                          acceptance_lines.append(line.strip()[2:])
                      elif line.startswith("  ") or line.startswith("\t"):
                          if acceptance_lines:
                              acceptance_lines[-1] += " " + line.strip()
                      elif not line.strip():
                          continue
                      else:
                          break

              if not acceptance_lines:
                  errors.append(f"Stage {code} missing acceptance block")
                  continue

              acceptance_text = normalize_text(" ".join(acceptance_lines))
              sot_acceptance = normalize_text(parser.rows[code][2])

              if acceptance_text != sot_acceptance:
                  errors.append(
                      f"Stage {code} acceptance mismatch:\n  SoT: {sot_acceptance}\n  Spec: {acceptance_text}"
                  )

              # Verify that the spec links back to the SoT anchor
              anchor = f"docs/Vision_v1_Investor_SoT.html#{code}"
              if anchor not in stage_md.read_text(encoding="utf-8"):
                  errors.append(f"Stage {code} missing SoT anchor link")

          if errors:
              raise SystemExit("\n".join(errors))
          PY

      - name: Ensure SoT anchors exist
        run: |
          python - <<'PY'
          from pathlib import Path

          sot_html = Path('docs/Vision_v1_Investor_SoT.html').read_text(encoding='utf-8')
          missing = []
          for idx in range(1, 18):
              code = f'S{idx:02d}'
              if f'id="{code}"' not in sot_html:
                  missing.append(code)
          if missing:
              raise SystemExit(f"Missing stage anchors: {missing}")
          PY
