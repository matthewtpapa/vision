# M1 Spec — Latency-Bounded Vertical Slice

**Scope:** End-to-end loop (detect → track → embed → match) with incremental KB updates, FAISS/NumPy matcher via factory, telemetry + `--eval`, latency-aware stride controller, minimal Python API façade.

## 1) Reference Hardware & Fixture

- CPU: 4C/8T Intel i7-1165G7 *or* Apple M1 (4 performance cores)
- Input: 640×640 frames (letterboxed/center-crop acceptable)  
- Warm-up: exclude first 100 frames from latency stats  
- Eval set: ≥2,000 frames, seeded order; includes known & unknown classes

## 2) API Contracts (typed; minimal façade)

```py
from typing import TypedDict, Any, Literal
import numpy as np

class Neighbor(TypedDict):
    label: str
    score: float  # cosine similarity in [-1, 1]

class MatchResult(TypedDict, total=False):
    label: str | Literal["unknown"]
    confidence: float          # equals top-1 cosine (uncalibrated in M1)
    neighbors: list[Neighbor]  # top-k, deterministic ordering
    evidence: dict[str, Any]   # optional, reserved
    is_unknown: bool

def add_exemplar(
    label: str,
    embedding: np.ndarray,
    *,
    bbox: tuple[int,int,int,int] | None = None,
    provenance: dict | None = None
) -> None:
    """Embeddings may be raw; SDK L2-normalizes to float32."""

def query_frame(frame: np.ndarray) -> MatchResult: ...
```

## 3) Similarity Semantics

- Cosine = dot product on L2-normalized float32 vectors; score ∈ [-1, 1]
- Deterministic tie-breaks: sort by score desc, then stable by insertion order  
- `topk` default=5; `threshold` default=0.35; `min_neighbors` default=1

## 4) Matcher Behavior

- Backend factory: prefer FAISS (IndexFlatIP) else NumPy fallback
- KB bootstrap on first query: load JSON exemplars → index (≤ 50 ms @ N=1k)  
- Incremental updates: listener adds new exemplars to in-memory index immediately  
- Unknown policy: `is_unknown = (#neighbors with score ≥ threshold) < min_neighbors`

## 5) Telemetry & `--eval`

CLI exports **JSON** and **CSV**. JSON schema (exact keys):

```json
{
  "stage_ms": {
    "detect": 0.0, "track": 0.0, "embed": 0.0, "match": 0.0, "overhead": 0.0
  },
  "fps": 0.0,
  "p50": 0.0,
  "p95": 0.0,
  "unknown_rate": 0.0,
  "kb_size": 0,
  "backend_selected": "faiss",
  "sdk_version": "0.1.0"
}
```

CSV columns: `stage,count,total_ms,mean_ms,max_ms`

## 6) Latency Budgets (reference CPU; CLIP-B32)

- Detect ≤ 15 ms | Track ≤ 2 ms | Embed ≤ 12 ms | Match ≤ 1 ms (@ N=1k) | Overhead ≤ 3 ms
- Pass gate: p95 ≤ 33 ms over ≥ 2,000 frames (warm-up excluded)

## 7) Config

- Single `vision.toml` with env overrides; expose `matcher.topk`, `matcher.threshold`, `matcher.min_neighbors`, `paths.kb_json`, `latency.budget_ms`, `pipeline.frame_stride`

## 8) Errors & Diagnostics

- `DimMismatchError`, `BackendUnavailableError`, `InvalidFrameError` (names reserved in M1; may be subclasses later)
- On backend import failure, factory logs fallback selection

## 9) Determinism

- Fixed seeds for any stochastic components
- Stable sort in matcher outputs  
- Deterministic CSV/JSON ordering; schema frozen for M1

## 10) Out-of-Scope (M1)

- Reverse image search loop, cloud KB, multi-backend detection/embedding, GPU acceleration

## 11) CI Gates

- `vision --eval` returns non-zero exit if p95 or bootstrap exceed targets
- JSON schema snapshot test; CSV columns check; stable ordering
- API example in README executes in type-checking CI (mypy/pyright)

